### HTTP基本原理

Web 内容都是存储在Web 服务器上的

Web 服务器所使用的是HTTP 协议

因此经常会被称为HTTP 服务器

这些**HTTP 服务器**存储了因特网中的数据

**HTTP 客户端**(比如浏览器)发出请求的话，它们会提供数据

**HTTP 服务器**，**HTTP 客户端**共同构成了万维网的基本组件。

### MIME(Multipurpose Internet Mail Extension，多用途因特网邮件扩展)

​		因特网上有数千种不同的数据类型，HTTP 仔细地给每种要通过Web 传输的对象都打上了名为MIME 类型（MIME type） 的数据格式标签1

​		最初设计MIME（Multipurpose Internet Mail Extension，多用途因特网邮件扩展）是为了解决在不同的电子邮件系统之间搬移报文时存在的问题。

​		HTTP 也**采纳了MIME 在电子邮件系统**，用它来描述并标记多媒体内容。

~~~txt
Web 服务器会为所有HTTP 对象数据附加一个MIME 类型当Web浏览器从服务器中取回一个对象时，会去查看相关的MIME 类型，看看它是否知道应该如何处理这个对象。大多数浏览器都可以处理数百种常见的对象类型：显示图片文件、解析并格式化HTML 文件、通过计算机声卡播放音频文件，或者运行外部5 插件软件来处理特殊格式的数据。
~~~

​		**MIME 类型是一种文本标记**，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。

**MIME的类型值, 有数百种,** 大家只需了解即可, 无需记忆，比如：

* HTML 格式的文本文档由 text/html 类型来标记。
*  普通的 ASCII 文本文档由 text/plain 类型来标记。
* JPEG 格式的图片为 image/jpeg 类型。
* GIF 格式的图片为 image/gif 类型。
* Apple 的 QuickTime 电影为 video/quicktime 类型。
*  微软的 PowerPoint 演示文件为 application/vnd.ms-powerpoint 类型。

MIME的类型链接：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types

### 网络地址的基本信息

​		**每个Web 服务器资源都有一个名字**，这样客户端就可以说明它们感兴趣的资源是什么了。**服务器资源名被称为统一资源标识符**（Uniform Resource Identifier，URI）。URI 就像因特网上的邮政地址一样，在世界范围内唯一标识并**定位信息资源**。

大部分URL 都遵循一种标准格式，这种格式包含三个部分。

1. URL 的第一部分被称为方案（scheme），说明了访问资源所使用的协议类型。这部分通常就是**HTTP 协议（http://）**。
2. 第二部分给出了服务器的**因特网地址**（比如，www.joes-hardware.com）。
3. 其余部分指定了 Web 服务器上的**某个资源**（比如，/specials/saw-blade.gif）。现在，几乎所有的URI 都是URL。

**专业的说法**：

​		几乎没有哪个URL 中包含了所有这些组件(不同类型的URL包含了里面的几个不同的部分)
​		URL **最重要**的3 个部分是**方案（scheme）、主机（host）和路径（path）**

方案分为如下几个方案：

​		![image-20201104114812898](C:\Users\申杰\AppData\Roaming\Typora\typora-user-images\image-20201104114812898.png)

![image-20201104114821166](C:\Users\申杰\AppData\Roaming\Typora\typora-user-images\image-20201104114821166.png)

~~~html
<a href="maillto 731303749@qq.com">发送到邮箱</a>
~~~



### HTTP请求的事务逻辑

​		一个HTTP 事务由一条（从客户端发往服务器的）请求命令和一个（从服务器发回客户端的）响应结果组成。这种通信是通过名为HTTP 报文（HTTP message）的格式化数据块进行的

#### 报文

​		**HTTP 报文是由一行一行的简单字符串组成的**。HTTP 报文都是**纯文本**，不是二进制代码，所以人们可以很方便地对其进行读写

​		从Web 客户端发往Web 服务器的HTTP 报文称为**请求报文**（request message）。从服务器发往客户端的报文称为**响应报文**（response message）

报文分为以下三个部分：

1. 起始行

   ​		报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况。

2. 首部字段

   ​		**起始行后面有零个或多个首部字段。**每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（:）来分隔。首部以一个空行结束。添加一个首部字段和添加新行一样简单。

3.  主体

   ​		空行之后就是可选的报文主体了，其中**包含了所有类型的数据**。请求主体中包括了要发送给Web 服务器的数据；响应主体中装载了要返回给客户端的数据。**起始行和首部都是文本形式且都是结构化的，而主体则不同**，主体中可以**包含任意的二进制数据**（比如图片、视频、音轨、软件程序）。当然，主体中**也可以包含文本**。

###### HTTP报文之报文流入源端服务器

​		HTTP 报文是在HTTP 应用程序之间发送的数据块

​		这些数据块以一些文本形式的元信息（meta-information）开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文在客户端、服务器和代理之间流动。术语“流入”、“流出”、“上游”及“下游”都是用来描述报文方向的。

​		**HTTP 使用术语流入（inbound）和流出（outbound）来描述事务处理（transaction）的方向**。<font color="red">**报文流入源端服务器**，</font>工作完成之后，会流回用户的Agent 代理中

###### HTTP报文之报文向下游流动

​		**HTTP 报文会像河水一样流动**。不管是请求报文还是响应报文，所有报文都会向下游（downstream） 流动。**所有报文的发送者都在接收者的上游（upstream）**(映衬了<font color="red">**报文流入源端服务器**，</font>这句话)

###### HTTP报文之报文格式详解

​			所有的HTTP 报文都可以分为两类： 请求报文（request message） 和响应报文（response message）。

 请求报文:

~~~html
<method> <request-URL> <version>
<headers>
<entity-body>
~~~

响应报文：(注意，只有起始行的语法有所不同)

~~~html
<version> <status> <reason-phrase>
<headers>
<entity-body>
~~~

所有的HTTP 报文都以一个起始行作为开始。请求报文的起始行说明了要做些什么。响应报文的起始行说明发生了什么。

对上述各部分的简要描述：

* 方法（method）

  客户端希望服务器对资源执行的动作。是一个单独的词，比如GET、HEAD 或POST。

* 请求URL（request-URL）

  命名了所请求资源，或者URL 路径组件的完整URL。如果直接与服务器进行对话，只要URL 的路径组件是资源的绝对路径，通常就不会有什么问题——服务器可以假定自己是URL 的主机/ 端口。

*  版本（version）

  报文所使用的HTTP 版本，其格式看起来是这样的：HTTP/<major>.<minor>其中主要版本号（major）和次要版本号（minor）都是整数。

* 状态码（status-code）

  这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般类别（“成功”、“出错”等）。

* 原因短语（reason-phrase）

  数字状态码的可读版本，包含行终止序列之前的所有文本。本章稍后提供了HTTP 规范定义的所有状态码的原因短语示例。原因短语只对人类有意义，因此，比如说，尽管响应行HTTP/1.0 200 NOT OK 和 HTTP/1.0 200 OK 中原因短语的含义不同，但同样都会被当作成功指示处理。

* 首部（header）

  可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（:），然后是一个可选的空格，接着是一个值，最后是一个CRLF。首部是由一个空行（CRLF）结束的，表示了首部列表的结束和实体主体部分的开始。有些HTTP 版本，比如HTTP/1.1，要求有效的请求或响应报文中必须包含特定的首部

* 实体的主体部分(entity-body)

  实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分，有时，报文只是以一个CRLF 结束

###### HTTP报文之报文方法详解

​		**最常用的就是GET和POST方法**, 这两个方法从HTTP的报文格式上就可以知道,一个携带了主体数据一个没有携带而只是靠请求的参数进行数据传递

| 方法    | 描述                                                 | 是否包含主体 |
| ------- | ---------------------------------------------------- | ------------ |
| GET     | 从服务器获取一份文档                                 | 否           |
| HEAD    | 只从服务器获取文档的首部                             | 否           |
| POST    | 向服务器发送需要处理的数据                           | 是           |
| PUT     | 将请求的主体部分存储到服务器                         | 是           |
| TRACE   | 对可能经过的代理服务器传送到服务器上去的报文进行追踪 | 否           |
| OPTIONS | 决定可以在服务器上执行哪些方法                       | 否           |
| DELETE  | 从服务器上删除一份文档                               | 否           |

1. GET 是最常用的方法。通常用于请求服务器发送某个资源。HTTP/1.1 要求服务器实现此方法

2. HEAD 方法与GET 方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分。

   可以在未获取资源的情况下：对资源的首部进行检查

   1. 使用HEAD，可以在不获取资源的情 况下了解资源的情况（比如，判断其类型）；
   2. 通过查看响应中的状态码，看看某个对象是否存在；
   3. 通过查看首部，测试资源是否被修改了。

3. 服务器开发者必须确保返回的首部与GET 请求所返回的首部完全相同。遵循HTTP/1.1 规范，就必须实现HEAD 方法

4. 与GET 从服务器读取文档相反，**PUT 方法会向服务器写入文档**。有些发布系统允许用户创建Web 页面，并用PUT 直接将其安装到Web 服务器上去,因为PUT 允许用户对内容进行修改，**所以很多Web 服务器都要求在执行PUT 之前，用密码登录**

5. POST 方法起初是用来向服务器输入数据的。实际上，**通常会用它来支持HTML的表单**。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方

   注：POST 用于向服务器发送数据。PUT 用于向服务器上的资源（例如文件）中存储数据

6. **TRACE 请求会在目的服务器端发起一个“环回”诊断**。行程最后一站的服务器会弹回一条TRACE 响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP 应用程序组成的请求/ 响应链上，原始报文是否，以及如何被毁坏或修改过

7. OPTIONS 方法请求Web 服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法

###### HTTP报文之报文状态码详解

​		方法是用来告诉服务器做什么事情的，状态码则用来告诉客户端，发生了什么事情。

​		可以通过三位数字代码对不同状态码进行分类。
​			200 到299 之间的状态码表示成功。
​			300 到399 之间的代码表示资源已经被移走了。
​			400 到499 之间的代码表示客户端的请求出错了。
​			500 到599 之间的代码表示服务器出错了。

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status

##### HTTP报文之报文首部详解

​		HTTP 首部字段向请求和响应报文中添加了一些附加信息。本质上来说，它们只是一些名/值对的列表。

​		HTTP 规范定义了几种首部字段。应用程序也可以随意发明自己所用的首部。HTTP首部可以分为以下几类。

* 通用首部

  既可以出现在请求报文中，也可以出现在响应报文中。

* 请求首部

  提供更多有关请求的信息

*  响应首部

  提供更多有关响应的信息。

* 实体首部

  描述主体的长度和内容，或者资源自身。

* 扩展首部

  规范中没有定义的新首部。每个HTTP 首部都有一种简单的语法：名字后面跟着冒号（ ：），然后跟上可选的空格，再跟上字段值，最后是一个CRLF

###### HTTP报文之请求报文首部详解

![image-20201104140820430](C:\Users\申杰\AppData\Roaming\Typora\typora-user-images\image-20201104140820430.png)

有些首部提供了与报文相关的最基本的信息，它们被称为通用首部。它们像和事佬儿一样，不论报文是何类型，都为其提供一些有用信息

![image-20201104140827398](C:\Users\申杰\AppData\Roaming\Typora\typora-user-images\image-20201104140827398.png)

请求首部是只在请求报文中有意义的首部。用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力。服务器可以根据请求首部给出的客户端信息，试着为客户端提供更好的响应

![image-20201104140913428](C:\Users\申杰\AppData\Roaming\Typora\typora-user-images\image-20201104140913428.png)

Accept 首部为客户端提供了一种将其喜好和能力告知服务器的方式，包括它们想要什么，可以使用什么，以及最重要的，它们不想要什么。这样，服务器就可以根据这些额外信息，对要发送的内容做出更明智的决定。**Accept 首部会使连接的两端都受益。客户端会得到它们想要的内容，服务器则不会浪费其时间和带宽来发送客户端无法使用的东西**

![image-20201104141023041](C:\Users\申杰\AppData\Roaming\Typora\typora-user-images\image-20201104141023041.png)

**有时客户端希望为请求加上某些限制**。比如，如果客户端已经有了一份文档副本，就希望只在服务器上的文档与客户端拥有的副本有所区别时，才请求服务器传输文档。通过条件请求首部，客户端就可以为请求加上这种限制，要求服务器在对请求进行响应之前，确保某个条件为真。

![image-20201104141102628](C:\Users\申杰\AppData\Roaming\Typora\typora-user-images\image-20201104141102628.png)

HTTP 本身就支持一种简单的机制，可以**对请求进行质询/ 响应认证**。这种机制要求客户端在获取特定的资源之前，先对自身进行认证，这样就可以使事务稍微安全一些。

###### HTTP报文之响应报文首部详解

![image-20201104141135013](C:\Users\申杰\AppData\Roaming\Typora\typora-user-images\image-20201104141135013.png)

**响应报文有自己的响应首部集**。响应首部为客户端提供了一些额外信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令。这些首部有助于客户端处理响应，并在将来发起更好的请求

![image-20201104141439022](C:\Users\申杰\AppData\Roaming\Typora\typora-user-images\image-20201104141439022.png)

内容首部提供了与实体内容有关的特定信息，说明了其类型、尺寸以及处理它所需的其他有用信息。比如，Web 浏览器可以通过查看返回的内容类型，得知如何显示对象。

### HTTP请求的事务逻辑之连接

​		**HTTP 是个应用层协议**。HTTP 无需操心网络通信的具体细节；它把联网的细节都交给了通用、可靠的**因特网传输协议TCP/IP**。**只要建立了TCP 连接**，客户端和服务器之间的报文交换就不会丢失、不会被破坏，也不会在接收时出现错序了。

###### TCP 提供了：

	1.  无差错的数据传输；
 	2. 按序传输（数据总是会按照发送的顺序到达）；
 	3. 未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去）

用网络术语来说**，HTTP 协议位于TCP 的上层**。HTTP 使用TCP 来传输其报文数据。

~~~txt
HTTP(应用层)--->TCP(传输层)---->IP(网络层)---->网络特有的链接接口(数据链接层)---->物理网络硬件(物理层)
~~~

​		在HTTP 客户端向服务器发送报文之前，需要用**网际协议**（Internet Protocol，IP）地址和端口号在客户端和服务器之间**建立一条TCP/IP 连接**。

**步骤如下**：

1. 浏览器从URL 中解析出服务器的主机名；
2. 浏览器将服务器的主机名转换成服务器的IP 地址；
3. 浏览器将端口号（如果有的话）从URL 中解析出来；
4. 浏览器建立一条与Web 服务器的TCP 连接；
5. 浏览器向服务器发送一条HTTP 请求报文；
6. 服务器向浏览器回送一条HTTP 响应报文
7. 关闭连接，浏览器显示文档。

###### TCP/IP的三次握手

1. 第一次握手：

   ​		**客户端向服务端发送网络包**, 当服务端接受到后就可以**得知****:客户端**可以**正常的发送信息**,以及**服务端**可以**正常的接受信息**

2. 第二次握手：

   ​	**服务端向客户端发送网络包**, 当客户端接受到后就可以**得知**（得知双方都正常的接收和发送）:服务端**可以正常接受信息和发送信息,** 并且**自己是可以正常的发送和接受信息**()

3. 第三次握手：

   ​	**客户端向服务端发送网络包**, 当服务端接受到后就可以得知:客户端的发送和接受**能力正常**,自己的发送和接受能力也正常

###### TCP/IP的四次挥手

​		当**客户端与服务器端关闭一个链接**通道时,同样需要**双方的确认**才行, 这个确认的过程需要四个步骤. 与建立连接只能是客户端向服务端发送不同, 关闭链接可以有任意一方发起

  1. 第一次挥手：

     **发起方发送 FIN报文**，代表断开连接

  2. 第二次挥手：

     接收方响应 ACK(确认字符) 报文，

     并在自己发送完未处理的报文后发送 FIN 报文
     
  3. 第三次挥手：

     发起方接收 ACK 报文后等待接收方的 FIN 报文，收到后发送 ACK 报文，自己进入 TIME_WAIT 状态，等待 2MSL(MSL是最大的报文存活时间,一般是30s,60s或是120s,主要是怕接收方没有接受到ACK报文) 后关闭连接

4. 第四次挥手：

   接收方收到 ACK 报文，关闭连接

总结回收过程：

​		发起方发送 fin报文，接收方响应ack和fin报文，发起方接收到ack报文和fin报文，接收方接收ack报文断开连接

### HTTP请求的事务逻辑之常见业务结构组件

1. 代理：

   代理位于客户端和服务器之间，接收所有客户端的HTTP 请求

   并将这些请求转发给服务器（可能会对请求进行修改之后转发）

   最常见的有一些绿坝(青少年网页内容过滤系统)或是VPN

2. 缓存

   Web 缓存（Web cache）或代理缓存（proxy cache）是一种特殊的HTTP 代理服务器，可以将经过代理传送的常用文档复制保存起来。

   下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了(比如本地的浏览器缓存)

3. 网关

   **网关（gateway）是一种特殊的服务器**，作为其他服务器的中间实体使用。

   通常用于将HTTP 流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。

   ~~~txt
   例: 一个HTTP/FTP 网关会通过HTTP 请求接收对FTP URI 的请求，但通过FTP协议来获取文档。得到的文档会被封装成一条HTTP 报文，发送给客户端
   ~~~

4. 隧道

   隧道（tunnel）是建立起来之后，就会在两条连接之间对原始数据进行盲转发(只负责转发数据但是不管转发的是啥)的HTTP 应用程序。HTTP 隧道通常用来在一条或多条HTTP 连接上转发非HTTP 数据，转发时不会窥探数据。

HTTP报文之抓包小工具Fiddler  wireshark